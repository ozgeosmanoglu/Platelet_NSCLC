---
title: "<center> RNA sequencing of Tumor-educated platelets <center>"
author: "<center> Ã–zge Osmanoglu <center>"
output: 
  pdf_document:
    fig_caption: yes
    toc: yes
  html_document:
    code_folding: show
    df_print: paged
    theme: yeti
    highlight: tango
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
date: " _`r Sys.Date()`_ "
---

```{r setup, include=FALSE}
library(rmarkdown)
library(tinytex)
library(knitr)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

````{r Step 0 - Prep Metadata, echo = FALSE}
library(GEOquery)
library(readr)
library(tidyverse)

#phenodata from geo and pub - combine ----
gse <- getGEO(filename="../data/meta_data/GSE89843_series_matrix.txt.gz", AnnotGPL=TRUE)
phenodata_geo <- gse@phenoData@data

phenodata_geo$'GEO ID (GSE89843)' <- gsub("Blood_Platelets_", "",phenodata_geo$title)
phenodata_geo$'GEO ID (GSE89843)' <- gsub("-Healthy Control-", "-HC-", phenodata_geo$'GEO ID (GSE89843)')

#phenodata from the publication Best et al., 2017
phenodata_pub <- readr::read_delim("../data/meta_data/GSE89843_Best_et_al_Cancer_Cell_2017_Table_S1_conversion_to_GEO.txt") 

#phenodata from ENA of bioproject PRJNA353588----
phenodata_ena <- read_csv(file = "../data/meta_data/SraRunTable.txt")
#find what features are needed

inputPhenos <- c("phenodata_ena", "phenodata_geo", "phenodata_pub")

importantFeatures <- list()
for (j in 1:length(inputPhenos)) {
  inputPheno <- get(inputPhenos[j])
  for (i in 1:ncol(inputPheno)) {
    #print(dim(table(inputPheno[i])))
    if (between(dim(table(inputPheno[i])), 2, 100)) {
      importantFeatures[[inputPhenos[j]]][i] <- colnames(inputPheno[i])
      importantFeatures <- lapply(importantFeatures, na.omit)
      
    }
  }
}

rm(i)
rm(j)

##

phenodataF <- merge(phenodata_geo, phenodata_pub, by = 'GEO ID (GSE89843)')
phenodataF <- phenodataF %>% dplyr::select(c(`GEO ID (GSE89843)`, geo_accession,
                                             `Sample name`, `Patient group`, submission_date,
                                             `Classification group`, `Storage time`, Hospital,
                                             Age, Gender, Smoking, Metastasis,
                                             Treatment, `Matched cohort`, `Full cohort`))


#find the duplicates
duplicates <- phenodata_ena[duplicated(phenodata_ena$`Sample Name`) | duplicated(phenodata_ena$`Sample Name`, fromLast=TRUE),]
duplist <- duplicates$Run

agg.dup <- aggregate(. ~`Sample Name`, duplicates, paste, collapse = "_", na.action=NULL)

phenodata_ena <- phenodata_ena[!phenodata_ena$Run %in% duplist,]
phenodata_ena <-  phenodata_ena %>% mutate(across(everything(), as.character))
phenodata_ena <- data.frame(rbind(phenodata_ena, agg.dup))
names(phenodata_ena)[names(phenodata_ena) == 'GEO_Accession..exp.'] <- "geo_accession"
phenodata_ena<- phenodata_ena %>% dplyr::select(Run,BioSample,Experiment,geo_accession, AvgSpotLen,
                                                  DATASTORE.filetype, DATASTORE.provider, DATASTORE.region)
phenodata_ena <- phenodata_ena %>% separate(BioSample, c('Biosample', NA), sep = "_",
                                  remove = T)
phenodata_ena <- phenodata_ena %>% separate(Experiment, c('Experiment', NA), sep = "_",
                                                          remove = T)
phenodata_ena <- phenodata_ena %>% separate(geo_accession, c('geo_accession', NA), sep = "_",
                                                          remove = T)    
phenodata_ena <- phenodata_ena %>% separate(DATASTORE.filetype, c('filetype', NA), sep = "_",
                                              remove = T)    
phenodata_ena <- phenodata_ena %>% separate(DATASTORE.provider, c('provider', NA), sep = "_",
                                              remove = T)   
phenodata_ena <- phenodata_ena %>% separate(DATASTORE.region, c('region', NA), sep = "_",
                                              remove = T)   
phenodata_ena <- phenodata_ena %>% separate(AvgSpotLen, c('AvgSpotLen', NA), sep = "_",
                                              remove = T)   

#combine all info ----

phenodataF <- merge(phenodataF, phenodata_ena, by = "geo_accession")
phenodataF <- separate_rows(phenodataF, Run, sep = "_")

#edit out special characters
colnames(phenodataF) <- gsub(" ","_",colnames(phenodataF))
colnames(phenodataF) <- gsub("\\(|\\)","",colnames(phenodataF))
phenodataF <- data.frame(sapply(phenodataF,function(x) {gsub(" ", "_", x)}))
phenodataF <- data.frame(sapply(phenodataF,function(x) {gsub(">", "longerT", x)}))
phenodataF <- data.frame(sapply(phenodataF,function(x) {gsub("<", "shorterT", x)}))

#change some colnames - create new name
colnames(phenodataF)[colnames(phenodataF) == "Classification_group"] <- "class"
phenodataF$sampleLabels <- c(paste0("LC",1:length(grep("NSCLC", phenodataF$class)))
                             ,paste0("HD", 1:length(grep("Non-cancer", phenodataF$class))))

phenodataF[sapply(phenodataF, is.character)] <- 
  lapply(phenodataF[sapply(phenodataF, is.character)],  as.factor)

phenodataF <- phenodataF %>% mutate_if(is.character,as.factor)

````

## Introduction

We downloaded the 779 samples (826 SRA files/runs) from ENA (Bioproject ID: PRJNA353588). The quality control of the fastq files were done with FastQC (Andrews, 2010) and fastp (Chen et al., 2018). fastp was also used to trim adapters and low-quality reads. After trimming, we indexed human GRCh38 cDNA/transcriptome with kallisto index and performed pseudoalignment to the with kallisto quant function (Bray et al., 2016). 

```{r Step 1 - Import Counts}
library(rhdf5)
library(tidyverse)
library(tximport) 
library(ensembldb)
library(EnsDb.Hsapiens.v86)

#set file paths to your dataset
path <- file.path(paste0("../data/raw_data/aligned/", phenodataF$Run), "abundance.tsv") 

#get annotations using organism-specific package
Tx <- transcripts(EnsDb.Hsapiens.v86, 
                  columns=c("tx_id", "gene_name", "entrezid"))
Tx <- as_tibble(Tx)
#need to change first column name to 'target_id'
Tx <- dplyr::rename(Tx, target_id = tx_id)
#save detailed annotation as TxOG
TxOG <- Tx
TxOG <- TxOG %>% rename_with(~"gene", gene_name)
#transcript ID needs to be the first column in the dataframe
Tx <- dplyr::select(Tx, "target_id", "gene_name")

#import all kallisto files with counts
Txi_gene <- tximport(path, 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, 
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)
```

***

## Data Exploration

### Heteroscedasticity

```{r Step 2.1 - Data Exploration - Check TPM}
# Load packages -----
suppressPackageStartupMessages({
library(tidyverse) 
library(edgeR) 
library(matrixStats)
library(cowplot) 
library(RUVSeq)
library(plotly)
library(DESeq2)
library(DEFormats)
library(glmGamPoi)
library(swamp)
library(ggpubr)
library(MetBrewer)
})

# Examine your data up to this point ----
myTPM <- Txi_gene$abundance
myCounts <- Txi_gene$counts

colnames(myCounts) <- phenodataF$sampleLabels
colnames(myTPM) <- phenodataF$sampleLabels

# Generate summary stats for your data ----
# 1st, calculate summary stats for each transcript or gene, and add these to your data matrix
# then use the base R function 'transform' to modify the data matrix (equivalent of Excel's '=')
# then we use the 'rowSds', 'rowMeans' and 'rowMedians' functions from the matrixStats package
myTPM.stats <- transform(myTPM, 
                         SD=rowSds(myTPM), 
                         AVG=rowMeans(myTPM),
                         MED=rowMedians(myTPM))


TPMplot <- ggplot(myTPM.stats) + 
  aes(x = SD, y = MED) +
  geom_point(shape=16, size=2) +
  geom_smooth(method=lm) +
  geom_hex(show.legend = T) +
  labs(y="Median", x = "Standard deviation",
       title="Transcripts per million (TPM)",
       subtitle="unfiltered, non-normalized data",
       caption="") +
  theme_cowplot()
TPMplot

```

Highly expressed genes have higher variation, while lowly expressed genes have smaller variation.

### Filtering and normalization

```{r Step 2.2 - Data Exploration - Collapse&Filter}

#Collapse technical replicates

#create Deseq dataset ----
ddsRaw <- DESeqDataSetFromTximport(Txi_gene, 
                                colData=phenodataF, 
                                design= ~class)
colnames(ddsRaw@assays@data@listData[["counts"]]) <- ddsRaw@colData@listData[["sampleLabels"]]

#collapse technical replicates
ddsColl <- collapseReplicates(ddsRaw, ddsRaw$geo_accession, ddsRaw$Run)

phenodataColl <- data.frame(ddsColl@colData@listData)
phenodataColl$Run <- phenodataColl$runsCollapsed
phenodataColl <- phenodataColl[1:23]

#remove the one sample from PISA hospital
rmix <- which(rownames(colData(ddsColl)) == "GSM2391029")
ddsColl <- ddsColl[,-rmix]
ddsColl$Hospital <- droplevels(ddsColl$Hospital)

colnames(ddsColl@assays@data@listData[["counts"]]) <-
  ddsColl@colData@listData[["sampleLabels"]]

#assign collapsed counts
myCountsColl <- ddsColl@assays@data@listData[["counts"]]
colnames(myCountsColl) <- ddsColl@colData@listData[["sampleLabels"]]

#Filtering low counts! ----
y <- as.DGEList(ddsColl)
keep <- filterByExpr(y) #design ~class 

y <- y[keep,] #20752 14545
ddsFilt <- ddsColl[keep,]

#plot the count distributions before and after filtering
inputCounts <-cpm(ddsColl@assays@data@listData[["counts"]], log = T)
dd <- reshape2::melt(inputCounts, variable.name = "sample")

densR <- ggplot(dd, aes(value, colour = Var2)) + geom_density() +
  theme_cowplot() +
  xlab("Log-cpm")+
  ggtitle("Raw Data")+
  theme(legend.position="none") + 
  xlim(min(dd$value), max(dd$value))

inputCounts <-cpm(ddsFilt@assays@data@listData[["counts"]], log = T)
dd <- reshape2::melt(inputCounts, variable.name = "sample")

densFilt <- ggplot(dd, aes(value, colour = Var2)) + geom_density() +
  theme_cowplot() +
  xlab("Log-cpm")+
  ggtitle("Filtered Data")+
  theme(legend.position="none") + 
  xlim(min(dd$value), max(dd$value))

ggarrange(densR, densFilt)
```

We first collapsed technical replicates (collapseReplicates from DESeq2) and removed the one sample from PISA hospital (GSM2391029). We filtered lowly expressed genes by using filterByExpr from edgeR (min.count = 10, design = ~class, min. group size = 376). This reduced the number of genes from `r nrow(ddsColl)` to `r nrow(ddsFilt)`

```{r Step 2.3 - Data Exploration - Check Library Sizes}
# Make a DGElist from your counts ----

##make the dge list for rawdata (before collapsing) ----
myDGEListRaw = as.DGEList(ddsRaw)
myDGEListColl <- as.DGEList(ddsColl)
myDGEListFilt <- as.DGEList(ddsFilt)

# The names argument tells the barplot to use the sample names on the x-axis
# The las argument rotates the axis names
LibSizeDF <- data.frame(Sample = myDGEListColl$samples$Run, 
                        Libsize = myDGEListColl$samples$lib.size,
                        Class = myDGEListColl$samples$group, 
                        Hospital =myDGEListColl$samples$Hospital,
                        Patient = myDGEListColl$samples$Patient_group,
                        StorageT = myDGEListColl$samples$submission_date)  %>%
  arrange(Libsize)  # Order by LibSize


#LibSizeDF$Sample <- factor(LibSizeDF$Sample, levels = LibSizeDF$Sample)
libsizeplot <- ggplot(LibSizeDF, aes(x = Sample, y = Libsize, fill = Patient)) +
  geom_bar(stat = "identity") +
  labs(x = "Sample", y = "Library Size", title = "Library Size per Sample")+
  theme(axis.text.x = element_blank())+
  scale_fill_met_d("Signac")
libsizeplot
```

Library sizes of `r ncol(ddsColl)` samples are shown in the figure. Colors are for each group.

```{r Step 2.4.1 - Data Exploration - PCA plots}
#variance-stabilizing transformation ----
vsd <- vst(ddsFilt, blind=F)
pc <- prcomp(t(assay(vsd)))

#calculate percentages
pc.var<-pc$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) # we can then use these eigenvalues to calculate the percentage variance explained by each PC

pca.res.df <- as_tibble(pc$x)
class = vsd$class

###find outliers ----
idx <- pc$x[,1] < -190 | pc$x[,2] > 100

myplot <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = class, shape = idx, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  labs(title="PCA plot of filtered data",
       caption=paste0("produced on ", Sys.time()))+
  coord_fixed()

ggplotly(myplot)

```

We performed variance-stabilizing transformation (vst from DESeq2) to explore the data with principal component analysis (PCA). We removed two outliers we observed in PCA plots (GSM2390915 and GSM2627443).

```{r Step 2.4.1.2 - Data Exploration - PCA plots2, fig.height=9}
###remove outliers and redo vst ----
class <- vsd$class
class <- class[!idx]
ddsFiltF <- ddsFilt[,!idx]
colData(ddsFiltF) <- droplevels(colData(ddsFiltF))

vsd <- vst(ddsFiltF, blind=F)
pc <- prcomp(t(assay(vsd)))

#calculate percentages
pc.var<-pc$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) # we can then use these eigenvalues to calculate the percentage variance explained by each PC

pca.res.df <- as_tibble(pc$x)

myplot1 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = class, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  labs(title="PCA plot w/o outliers",
       caption=paste0("produced on ", Sys.time()))+
  coord_fixed()
  #scale_color_met_d("Veronese")

pca.res.df <- pc$x[,1:4] %>% 
  as_tibble() %>%
  add_column(sample = vsd$sampleLabels,
             group = class, 
             hospital = vsd$Hospital,
             W5 = vsd$W5,
             disease = vsd$Patient_group)

pca.pivot <- pivot_longer(pca.res.df, # dataframe to be pivoted
                          cols = PC1:PC4, # column names to be stored as a SINGLE variable
                          names_to = "PC", # name of that new variable (column)
                          values_to = "loadings") # name of new variable (column) storing all the values (data)

myplot2 <- ggplot(pca.pivot) +
  aes(x=sample, y=loadings, fill=disease) + 
  geom_bar(stat="identity") +
  facet_wrap(~PC) +
  labs(title="PCA 'small multiples' plot",
       caption=paste0("produced on ", Sys.time())) +
  theme_cowplot() +
  coord_flip()+
  theme(axis.text.y = element_blank())

plot_grid(
  myplot1, myplot2,
  labels = c('A', 'B'),
  align="hv",
  nrow = 2,
  ncol = 1
)

```

After removing outliers, we reprepare the PCA plot (Figure A). We can also see the first 4 PCs causing variation in the data (Figure B).

```{r Step 2.4.2 - Data Exploration - Prince plots, echo=FALSE}

mydds <- ddsFiltF #ddsRaw or ddsColl
myswamp <- mydds@assays@data@listData[["counts"]]  

#myswamp <- assay(vsd)

set.seed(19)
o1<-data.frame(Class = mydds$class,
               Disease = mydds$Patient_group,
               Hospital = mydds$Hospital,
               StorageTime = mydds$Storage_time, 
               Gender = mydds$Gender,
               Age = mydds$Age,
               Smoking = mydds$Smoking,
               Treatment = mydds$Treatment,
               Metastasis = mydds$Metastasis,
               SubmissionDate = mydds$submission_date,
               DataProvider = mydds$provider,
               Random = rnorm(ncol(myswamp)), row.names=colnames(myswamp))


# PCA analysis
res1<-prince(myswamp,o1,top=10,permute=F)
#beep(sound=2)

pp1 <- prince.plot(prince=res1, key = T, note = T, breaks = 16, colsep = 1:9,
            col =  rev(colorRampPalette(c("white", "lightgray", 
                                          "gold", "orange", "red"))(15)))
```


```{r Step 2.5.1 - Data Exploration - Estimate RUV1}
###estimate RUV factors + technical variation----
#https://github.com/mikelove/preNivolumabOnNivolumab/blob/main/preNivolumabOnNivolumab.knit.md

#First we see what happens when we run simple DESeq2 analysis comparing the two groups, 
#without attempting to control for the technical variation. Here we use glmGamPoi which 
#is an efficient method for estimating dispersion when we have many samples. This can 
#speed up the analysis by an order of magnitude. For details, see: https://doi.org/10.1093/bioinformatics/btaa1009

ddsIn <- ddsFiltF
ddsIn <- DESeq(ddsIn, test="LRT", reduced=~1, fitType="glmGamPoi")

res <- results(ddsIn)
table(res$padj < .05)

```

There are thousands of differentially expressed (DE) genes, which, as we will demonstrate, stem from uncontrolled confounding factors. Ignoring technical variation is not suitable when it correlates with the condition.

```{r Step 2.5.2 - Data Exploration - Estimate RUV2}

set <- newSeqExpressionSet(counts(ddsIn))
set <- betweenLaneNormalization(set, which="upper")
not_sig <- rownames(res)[which(res$padj > .05 & abs(res$log2FoldChange) < .05)]
empirical <- rownames(set)[ rownames(set) %in% not_sig ]
set <- RUVg(set, empirical, k=5)

pdat <- pData(set)
pdat$class <- class

vsd$W1 <- pdat$W_1
vsd$W2 <- pdat$W_2
vsd$W3 <- pdat$W_3
vsd$W4 <- pdat$W_4
vsd$W5 <- pdat$W_5

#We can visualize how the factors of unwanted variation describe the samples 
#in the PC1 and PC2 space:

pc <- prcomp(t(assay(vsd)))

#calculate percentages
pc.var<-pc$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) # we can then use these eigenvalues to calculate the percentage variance explained by each PC
pca.res.df <- as_tibble(pc$x)

hospitalplot <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$Hospital, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  guides(color=guide_legend(title="hospital"))+
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_brewer(palette = "Set1")  

p1 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$W1, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  guides(color=guide_colourbar(title="UV1"))+
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_met_c("VanGogh1")

p2 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$W2, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  guides(color=guide_colourbar(title="UV2"))+
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_met_c("VanGogh1")

p3 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$W3, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  guides(color=guide_colourbar(title="UV3"))+
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_met_c("VanGogh1")

p4 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$W4, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  guides(color=guide_colorbar(title="UV4"))+
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_met_c("VanGogh1")


p5 <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, color = vsd$W5, text = vsd$Run)+
  geom_point()+
  theme_bw() +
  guides(color=guide_colorbar(title="UV5"))+
  #geom_label(nudge_y = 0, nudge_x = 0) +
  #stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")"))+
  ylab(paste0("PC2 (",pc.per[2],"%",")"))+ 
  coord_fixed()+
  scale_color_met_c("VanGogh1")



figure <- ggarrange(p1,p2,p3,p4,p5,hospitalplot,
          #labels = c("UV1", "UV2", "UV3", "UV4", "UV5"),
          #font.label = list(size = 10, face = "bold"),
          ncol = 2, nrow = 3, vjust = 1.5, hjust = -1)



figureAnnot <- annotate_figure(figure,
                top = text_grob("Unwanted Variation in Filtered Data", face = "bold", size = 12),
                bottom = text_grob("(vst, outlier removed)",
                                   hjust = 1, x = 1, size = 10))
figureAnnot

```

Next, we checked for unwanted variation (UV) in the data using RUVg from RUVSeq. For this, we generated a list of stable (empirical) genes. We fit a Gamma-Poisson generalized linear model to the filtered data and ran a likelihood ratio test (LRT) to find genes that do not have changes in their expression across different levels of the experimental conditions (~class). We then defined the empirical genes as the genes with log2FC between -0.05 and 0.05 and with adjusted p-values larger than 0.05. We ended up with `r length(empirical)` genes as empirical genes and using this list we performed RUV with k=5. 

***

## Differential Gene Expression (DGE) Analysis

### DGE Analysis with DESeq2

```{r Step 3.1.1 - DGE Analysis with DESeq2 - Prepare}
library("apeglm")
library(DESeq2)
library(gt)
library(biomaRt)
library(org.Hs.eg.db)
library(tibble)
library(dplyr)

#add variation factors to design and do DGE analysis----
colData(ddsIn) <- cbind(colData(ddsIn), pdat[,1:5])
design(ddsIn) <- ~W_1 + W_2 + W_3 + W_4 + W_5 + class

```

We included the 5 UV factors in the design matrix alongside the condition of interest (~class: non-cancer vs. NSCLC) and performed differential expression (DE) analys is with DESeq from DESeq2. 

```{r Step 3.1.2 - DGE Analysis with DESeq2 - Sub, eval=FALSE}
#check dispersion to figure out the fit type----
#following https://support.bioconductor.org/p/81094/

DDS <- estimateSizeFactors(ddsIn)
par <- estimateDispersions(DDS, fitType = "parametric")
loc <- estimateDispersions(DDS, fitType = "local")
glmgam <- estimateDispersions(DDS, fitType = "glmGamPoi")

par(mfrow =c(1,3))
plotDispEsts(glmgam, main= "dispEst: glmGamPoi")
plotDispEsts(par, main= "dispEst: parametric")
plotDispEsts(loc, main= "dispEst: local")


#check residuals to decide on fit type
residualg <- log(mcols(glmgam)$dispGeneEst) - log(mcols(glmgam)$dispFit)
residualp <- log(mcols(par)$dispGeneEst) - log(mcols(par)$dispFit)
residuall <- log(mcols(loc)$dispGeneEst) - log(mcols(loc)$dispFit)

residualsT <- tibble("fit type" = c("glmGamPoi", "parametric", "local"),
          "median absolute residual" =c(median(abs(residualg), na.rm = T),
                                      median(abs(residualp), na.rm = T),
                                      median(abs(residuall), na.rm = T)))

residualsT %>%
  gt() %>%
  fmt_number(columns=2, decimals = 3) %>%
  tab_header(title = md("**Dispersion Estimates**"),
             subtitle = md("**to choose fit type***")) %>%
  tab_source_note(
    source_note = md("*the type of fitting of dispersions to the mean intensity."))
```

We tried three diffent methods to estimate dispersions and chose the one with lowest log10-residual.

```{r Step 3.1.3 DGE Analysis with DESeq2 - Main}
#run with selected fit type----

dds <- DESeq(ddsIn, test="LRT", reduced=~W_1 + W_2 + W_3 + W_4 + W_5,
             fitType="glmGamPoi")

resD<- results(dds, name ="classNSCLC")
plotMA(resD,ylim=c(-2,2))

#Get results in tibbles ----
resD_tb <- resD %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()

##get descriptions for the genes----
annotations <- read.csv("../data/processed_data/resD_tb_annotations.csv", row.names = 1)

##get differentially expressed genes----
padj.cutoff <- 0.05
lfc.cutoff <- 0.58

resD_sig <- resD_tb %>% dplyr::filter(padj < padj.cutoff & abs(log2FoldChange) > lfc.cutoff)
resD_sig0 <- resD_tb %>% dplyr::filter(padj < padj.cutoff)

orderedRes <- resD_tb %>% arrange(padj)
#write.csv(orderedRes, file="../data/processed_data/Deseq2Results.csv")
normCountsD <- counts(dds, normalized = TRUE)

##histograms ----
hist(resD$log2FoldChange, 
     col = "white",
     breaks = 100,
     #breaks=0:50/50, 
     xlab="log2FC", main="Histogram of log2FCs")
abline(v = c(-0.5, 0.5), col = "#973d21", lwd = 1.5, lty = 'dashed')

hist(resD$pvalue, 
     col = "white",
     breaks=0:50/50,
     xlab="p value", main="Histogram of p values")
abline(v = c(0.05, 0.01), col = c("#e78429","#ab3329"), lwd = 1.5, lty = 'dashed')
text(x=0.025, y=6200, '0.01', col="#ab3329", srt = 270, cex = 0.8)
text(x=0.065, y=6200, '0.05', col="#e78429", srt = 270, cex = 0.8)
```

Genes that have log2FC values smaller than -0.58 and larger than 0.58 adjusted p-values smaller than 0.05 were classified as differentially expressed genes. 

```{r Step 3.1.4 DGE Analysis with DESeq2 - Results Tables, include = FALSE}
#add descriptions
resD_sig2 <- merge(resD_sig, annotations, by='gene', all.x = T) %>% 
  distinct(., gene, .keep_all = T)

resD_sig2$description <- unlist(lapply(strsplit(as.character(resD_sig2$description), "\\["), '[[', 1))

##prepare publication tables----

number = 20

topnD <- resD_sig2 %>% 
  arrange(desc(abs(log2FoldChange))) %>%
  head(n=number)

topnD$pvalue <- sprintf('%.2e', topnD$pvalue)
topnD$padj<- sprintf('%.2e', topnD$padj)

#make the gt table
topnD %>%
  dplyr::select(c(gene,description, baseMean,log2FoldChange, pvalue, padj)) %>%
  gt()  %>%
  fmt_number(columns=c(2:5), decimals = 2) %>%
  cols_width(
    gene ~ px(120),
    pvalue ~ px(200),
    padj ~ px(200),
    description ~ px(1000)) %>%
  cols_label(gene = md("**gene**"),
             baseMean = md("**base mean**"),
             log2FoldChange = md("**log2FC**"),
             pvalue = md("**p-value**"),
             padj = md("**adj. p-value**"),
             description = md("**description**")
             ) %>%
  cols_align("center",
             columns = 3:6) %>%
  tab_header(title = md(paste0("Top ", number,  " differentially regulated genes")),
             #subtitle = md("**to choose fit type***")
             )
```

```{r Step 3.1.5 DGE Analysis with DESeq2 - Volcano plot, fig.height=6, fig.width=8}
library(EnhancedVolcano)

top.x = resD_tb
top.x.b <- top.x[abs(top.x$log2FoldChange) > 0.58,]
top.x.b <- top.x.b[order(top.x.b$padj),]
GeneSymbol <- top.x$gene
GeneSymbol2 <- top.x.b$gene

print(EnhancedVolcano(top.x,
                      lab = GeneSymbol,
                      selectLab = GeneSymbol2[1:30],
                      col = c("grey30",  "#7db0ea", "#89ab7c", "#a00e00"),
                      x = 'log2FoldChange',
                      y = 'padj',
                      xlab = bquote(~Log[2]~ 'fold change'),
                      pCutoff = 0.05,
                      FCcutoff = 0.58,
                      cutoffLineType = 'twodash',
                      cutoffLineWidth = 0.8,
                      pointSize = 2.0,
                      labSize = 4.0,
                      colAlpha = 0.3,
                      axisLabSize = 12,
                      legendLabels=c('Not sig.','Not sig. Log2FC','adj.p.value',
                                     'adj.p.value & Log2FC'),
                      legendPosition = 'right',
                      legendLabSize = 12,
                      legendIconSize = 4.0,
                      drawConnectors = TRUE,
                      widthConnectors = 0.5,
                      maxoverlapsConnectors = 50,
                      boxedLabels = T,
                      xlim = c(-2, 2),
                      ylim = c(0, -log10(min(top.x$padj))*1.1),
                      title = "NSCLC vs. nonCancer"))

```

```{r Step 3.1.6 DGE Analysis with DESeq2 - Results Figures}
####make count plots----
dds$Patient_group <- gsub("_", " ", dds$Patient_group)
dds$Patient_group <- factor(dds$Patient_group)


#for multiple #for multiple #for multiple genes

gene_set <- topnD$gene[1:6]
names(gene_set) <- gene_set

for (i in 1:length(gene_set)) {
  gene <- gene_set[i]
  
  d <- plotCounts(dds, gene=gene, intgroup="class", 
                  returnData=TRUE)
  
  mean_team <- d %>% group_by(class) %>% 
    summarise(mean_pts=mean(count))
  plot <- ggplot(d, aes(x=class, 
                        y=count, 
                        colour = class)) + 
    geom_point(position=position_jitter(w=0.1,h=0)) +
    scale_y_log10(breaks=c(25,100,400,1000))+
    theme_cowplot() +
    ggtitle(gene)+
    theme(legend.position = "none", axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(),
          axis.title.x = element_blank(),
          strip.background = element_rect(fill="white"),
          strip.placement = "outside",
          strip.clip = "off",
          strip.text = element_text(size = 12, angle = 90, hjust = 1)) +
    facet_grid(~class, 
               shrink = F, scales = "free", space = "free", switch = "x") +
    geom_hline(aes(yintercept = mean_pts, color = class), 
               mean_team, linewidth = 1)
  
  assign(paste0("plot", i), plot)
  
}
classplot <- ggarrange(plot1, plot2, plot3, plot4, plot5, plot6)

for (i in 1:length(gene_set)) {
  gene <- gene_set[i]
  
  d <- plotCounts(dds, gene=gene, intgroup="Patient_group", 
                  returnData=TRUE)
  
  mean_team <- d %>% group_by(Patient_group) %>% 
    summarise(mean_pts=mean(count))
  plot <- ggplot(d, aes(x=Patient_group, 
                        y=count, 
                        colour = Patient_group)) + 
    geom_point(position=position_jitter(w=0.1,h=0)) +
    scale_y_log10(breaks=c(25,100,400))+
    theme_cowplot() +
    ggtitle(gene)+
    theme(legend.position = "none", axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(),
          axis.title.x = element_blank(),
          strip.background = element_rect(fill="white"),
          strip.placement = "outside",
          strip.clip = "off",
          strip.text = element_text(size = 12, angle = 90, hjust = 1)) +
    facet_grid(~Patient_group, labeller = label_wrap_gen(width=10), 
               shrink = F, scales = "free", space = "free", switch = "x") +
    geom_hline(aes(yintercept = mean_pts, color = Patient_group), 
               mean_team, linewidth = 1)
  
  assign(paste0("plot", i), plot)
  
}
patientplot <- ggarrange(plot1, plot2, plot3, plot4, plot5, plot6)
```

```{r figure, fig.height=12, fig.width=8}
ggarrange(classplot, patientplot, nrow =2, ncol = 1)
```

### DGE Analysis with Limma

```{r Step 3.2.1 - DGE Analysis with Limma-voom - Main, fig.height=4, fig.width=4}
library(edgeR)
library(gt)
library(DEFormats)
library(Glimma)
library(DT)

myDGEListIn <- as.DGEList(ddsIn)
myDGEListIn.norm <- calcNormFactors(myDGEListIn, method = "TMM")
myDGEListIn.norm$samples <- droplevels(myDGEListIn.norm$samples)

group <- myDGEListIn.norm$samples$group
W_1 <- myDGEListIn.norm$samples$W_1
W_2 <- myDGEListIn.norm$samples$W_2
W_3 <- myDGEListIn.norm$samples$W_3
W_4 <- myDGEListIn.norm$samples$W_4
W_5 <- myDGEListIn.norm$samples$W_5

design <- model.matrix(~0 + group + W_1 + W_2 + W_3 + W_4 + W_5)
colnames(design)[1:2] <- c("noncancer", "NSCLC")

v.myDGEListIn.norm <- voom(myDGEListIn.norm, design, plot = TRUE)

#fit linear model
fit <- lmFit(v.myDGEListIn.norm, design)

# Contrast matrix ----
contrast.matrix <- makeContrasts(NSCLC - noncancer, levels = design) #limma

# extract the linear model fit -----
fits <- contrasts.fit(fit, contrast.matrix)
#get bayesian stats for your linear model fit
ebFit <- eBayes(fits)

#make MAplot
limma::plotMA(fits, ylim=c(-2,2))
abline(h=0, col="red", lwd=2)

```

```{r Step 3.2.2. DGE Analysis with Limma-voom - Results}
top.table <- topTable(ebFit, adjust ="BH", sort.by = "P", n = Inf)

resL_tb <- top.table %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()

orderedResL <- resL_tb %>% arrange(adj.P.Val)
orderedResL <- merge(orderedResL, annotations, by='gene', all.x = T) %>% 
  distinct(., gene, .keep_all = T)
orderedResL <- merge(orderedResL, TxOG[6:8], by='gene', all.x = T) %>% 
  distinct(., gene, .keep_all = T)

orderedResL$description <- unlist(lapply(strsplit(as.character(orderedResL$description), "\\["), '[[', 1))
orderedResL <- orderedResL %>% dplyr::select(gene, description, target_id, entrezid, logFC, AveExpr, P.Value, adj.P.Val)
orderedResL$entrezid <-  unlist(sapply(orderedResL$entrezid,"[[",1))

#histograms ----
hist(resL_tb$logFC, 
     col = "white",
     breaks = 100,
     #breaks=0:50/50, 
     xlab="log2FC", main="Histogram of log2FCs")
abline(v = c(-0.5, 0.5), col = "#973d21", lwd = 1.5, lty = 'dashed')


hist(resL_tb$P.Value, 
     col = "white",
     breaks=0:50/50,
     xlab="p value", main="Histogram of p values")
abline(v = c(0.05, 0.01), col = c("#e78429","#ab3329"), lwd = 1.5, lty = 'dashed')
text(x=0.025, y=5800, '0.01', col="#ab3329", srt = 270, cex = 0.8)
text(x=0.065, y=5800, '0.05', col="#e78429", srt = 270, cex = 0.8)
```

```{r Step 3.2.3 - DGE Analysis with Limma-voom - Results Tables}

##get differentially expressed genes----
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.05, lfc=0.58)
diffGenes <- v.myDGEListIn.norm$E[results[,1] !=0,]

#convert your DEGs to a dataframe using as_tibble
diffGenes.df <- as_tibble(diffGenes, rownames = "geneID")

#get sig dfs----
padj.cutoff <- 0.05
lfc.cutoff <- 0.58

resL_sig <- resL_tb %>%
  dplyr::filter(`adj.P.Val` < padj.cutoff & abs(logFC) > lfc.cutoff)

resL_sig0 <- resL_tb %>%
  dplyr::filter(`adj.P.Val` < padj.cutoff)

##make the top table----

#add descriptions
resL_sig2 <- merge(resL_sig, annotations, by='gene', all.x = T) %>% 
  distinct(., gene, .keep_all = T)

resL_sig2$description <- unlist(lapply(strsplit(as.character(resL_sig2$description), "\\["), '[[', 1))

# create interactive tables to display your DEGs ----

resL_sig2 <- resL_sig2 %>% dplyr::select(gene, description, AveExpr, logFC, P.Value, adj.P.Val)
datatable(resL_sig2,
          extensions = c('KeyTable', "FixedHeader"),
          caption = 'Table 1: DEGs in NSCLC',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(3:6), digits=2)
```

```{r Step 3.2.3 - DGE Analysis with Limma-voom - Results Tables2, include=FALSE}
##prepare publication tables----
number = 20

topnL <- resL_sig2 %>% 
  arrange(desc(abs(logFC))) %>%
  head(n=number)

topnL$P.Value <- sprintf('%.2e', topnL$P.Value)
topnL$adj.P.Val<- sprintf('%.2e', topnL$adj.P.Val)

#make the gt table
topnL %>%
  dplyr::select(c(gene,description, AveExpr,logFC, P.Value, adj.P.Val)) %>%
  gt()  %>%
  fmt_number(columns=c(2:5), decimals = 2) %>%
  cols_width(
    gene ~ px(300),
    P.Value ~ px(200),
    adj.P.Val ~ px(200),
    description ~ px(1000)) %>%
  cols_label(gene = md("**gene**"),
             AveExpr = md("**Avg. exp.**"),
             logFC = md("**log2FC**"),
             P.Value = md("**p-value**"),
             adj.P.Val = md("**adj. p-value**"),
             description = md("**description**")
  ) %>%
  cols_align("center",
             columns = 3:6) %>%
  tab_header(title = md(paste0("Top ", number,  " differentially regulated genes")),
             #subtitle = md("**to choose fit type***")
  )
```

```{r Step 3.2.4 - DGE Analysis with Limma-voom - Compare Deseq2 and Limma}

#compare DESeq and Limma----
library(ggVennDiagram)

v0 <- ggVennDiagram(list(topnD$gene, topnL$gene),
              category.names = c("DESeq2", "Limma voom"),
              label_alpha = 0,
              set_size = 4,
              set_color = "#5F5F5F",
              edge_size = 0)+
  scale_fill_gradient(low = "#f6f2ee", high =  "#E4B09A")+
  #scale_x_continuous(expand = expansion(mult = .3))+
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 12, colour = "#5F5F5F", face = "bold"),
        plot.subtitle  = element_text(hjust = 0.5, colour = "#5F5F5F"))+
  labs(title = "Top 20 genes",
       subtitle = "assessed by two methods")+
  coord_flip()

v1 <- ggVennDiagram(list(resD_sig$gene, resL_sig$gene),
              category.names = c("DESeq2", "Limma voom"),
              label_alpha = 0,
              set_size = 4,
              set_color = "#5F5F5F",
              edge_size = 0) +
  scale_fill_gradient(low = "#f6f2ee", high =  "#87bcbd")+
  scale_x_continuous(expand = expansion(mult = .3))+
  #coord_flip()+
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 12, colour = "#4E696A", face = "bold"),
        plot.caption = element_text(hjust = 0.5, colour = "#5F5F5F"))+
  labs(title = "Differentially expressed genes",
       caption = "|log2FC| > 0.58 & adj.p-value < 0.05")


v2 <- ggVennDiagram(list(resD_sig0$gene, resL_sig0$gene),
              category.names = c("DESeq2", "Limma voom"),
              label_alpha = 0,
              set_size = 4,
              set_color = "#5F5F5F",
              edge_size = 0) +
  scale_fill_gradient(low = "#f6f2ef", high =  "#7c4b73")+
  scale_x_continuous(expand = expansion(mult = .3))+
  #coord_flip()+
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 12, colour = "#52334C", face = "bold"),
        plot.caption = element_text(hjust = 0.5, colour = "#5F5F5F"))+
  labs(title = "Significantly expressed genes",
       caption = "adj.p-value < 0.05")

ggarrange(v1,v2)

```

```{r Step 3.2.5 - DGE Analysis with Limma-voom - Volcano Plots, fig.height=6, fig.width=8}
library(EnhancedVolcano)

top.x = resL_tb
top.x.b <- top.x[abs(top.x$logFC) > 0.58,]
top.x.b <- top.x.b[order(top.x.b$adj.P.Val),]
GeneSymbol <- top.x$gene
GeneSymbol2 <- top.x.b$gene

print(EnhancedVolcano(top.x,
                      lab = GeneSymbol,
                      selectLab = GeneSymbol2[1:30],
                      col = c("grey30",  "#7db0ea", "#89ab7c", "#a00e00"),
                      x = 'logFC',
                      y = 'adj.P.Val',
                      xlab = bquote(~Log[2]~ 'fold change'),
                      pCutoff = 0.05,
                      FCcutoff = 0.58,
                      cutoffLineType = 'twodash',
                      cutoffLineWidth = 0.8,
                      pointSize = 2.0,
                      labSize = 4.0,
                      colAlpha = 0.5,
                      axisLabSize = 12,
                      legendLabels=c('Not sig.','Not sig. Log2FC','adj.p.value',
                                     'adj.p.value & Log2FC'),
                      legendPosition = 'right',
                      legendLabSize = 12,
                      legendIconSize = 4.0,
                      drawConnectors = TRUE,
                      widthConnectors = 0.5,
                      maxoverlapsConnectors = 50,
                      boxedLabels = T,
                      xlim = c(-2, 2),
                      ylim = c(0, -log10(min(top.x$adj.P.Val))*1.1),
                      title = "NSCLC vs. nonCancer"
))

```

***
## Clustering DEGs

```{r Step 4.1 - Clustering all genes}

# Description -----------
#this script creates heatmaps from differentially expressed genes or transcripts
#and selects modules of co-expressed genes based on pearson correlations

# Load packages -----
library(tidyverse)
library(limma) #we only use limma in this script for the 'avearrays' function
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(pheatmap)
library(cowplot)
library(plyr)

# Choose Colors ----
myheatcolors <- colorRampPalette(colors=c("blue","white","red"))(100)

# Prepare Data----
vIn <- v.myDGEListIn.norm
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.05, lfc=0.58)
disease <- myDGEListIn$samples$Patient_group
disease <- revalue(disease, c("Chronic_Pancreatitis" = "Chronic Pancreatitis",
                              "Epilepsy" = "Epilepsy",
                              "Healthy_Control" = "Healthy",
                              "Multiple_Sclerosis" = "MS",
                              "Non-significant_atherosclerosis" = "NS Atherosclerosis",
                              "NSCLC" = "NSCLC",
                              "Pulmonary_Hypertension" = "Pulmonary Hypertension",
                              "Stable_Angina_Pectoris" = "Stable AP",
                              "Unstable_Angina_Pectoris" =  "Unstable AP"))

colnames(vIn$E) <- disease
AllGenesHeatmap <- vIn$E
diffGenesHeatmap <- vIn$E[results[,1] !=0,]

#now an old function from the limma package to average your replicates 
AllGenes.AVG <- avearrays(AllGenesHeatmap)
AllGenes.AVG <- AllGenes.AVG[,order(colnames(AllGenes.AVG))]

write.csv(AllGenes.AVG, file="../data/processed_data/LimmaCountsAveraged.csv")

diffGenes.AVG <- avearrays(diffGenesHeatmap)
diffGenes.AVG <- diffGenes.AVG[,order(colnames(diffGenes.AVG))]

pheatmap(mat = AllGenes.AVG, 
         color = myheatcolors,,
         fontsize_col = 11,
         angle_col = 45,
         cellwidth = 30,
         cellheight = 0.02,
         scale="row",
         border_color = NA, 
         show_colnames = TRUE, 
         show_rownames = F, 
         #drop_levels = TRUE, 
         fontsize = 10, 
         cluster_cols = T,
         cluster_rows = T,
         clustering_distance_cols=as.dist(1-cor(AllGenes.AVG, method="spearman")),
         cex=1,
         main = "")

```

```{r Step 4.2 - Clustering DEGs, include=FALSE}
# Cluster the data using heatmap ----
set.seed(1508)
clustered_data <- pheatmap(diffGenes.AVG,
         myheatcolors, scale="row", na_col = "grey",
         border_color = "black", 
         fontsize_col = 11,
         cellwidth = 20,
         cellheight = 15,
         angle_col = 45,
         show_colnames = TRUE, 
         show_rownames = TRUE,
         drop_levels = TRUE, 
         fontsize = 10, 
         cluster_cols = TRUE,
         cluster_rows = F,
         cex=1,
         kmeans_k = 9, 
         clustering_distance_rows="correlation", 
         clustering_distance_cols=as.dist(1-cor(diffGenes.AVG, method="spearman")), ##note: we use Spearman, instead of Pearson, for clustering samples because it gives equal weight to highly vs lowly expressed transcripts or genes
         clustering_method="complete",
         main = "")

# Add cluster information to your count matrix ----
data_subset_norm.clust <- cbind(diffGenes.AVG, cluster = clustered_data$kmeans$cluster)
data_subset_norm.clust <- as.data.frame(data_subset_norm.clust)

# Order count matrix by cluster number
data_subset_norm.clust.ordered <- data_subset_norm.clust[order(data_subset_norm.clust$cluster, decreasing = F),]
row_annots <- as.data.frame(paste0("mod ", data_subset_norm.clust.ordered$cluster))
rownames(row_annots) <- rownames(data_subset_norm.clust.ordered)
colnames(row_annots) = "module"

# Choose cluster colors ----
annot_colors <- list(module = brewer.pal(9, "PRGn"))
names(annot_colors$module) <- unique(row_annots$module)
annot_colors$module[5] <- "burlywood"

# Make heatmap showing all clusters ----

HM <-  pheatmap(mat = data_subset_norm.clust.ordered[1:9], 
         color = myheatcolors,,
         fontsize_col = 11,
         angle_col = 45,
         cellwidth = 30,
         cellheight = 0.5,
         gaps_row=cumsum(as.numeric(table(row_annots$module))),
         scale="row",
         border_color = NA, 
         show_colnames = TRUE, 
         show_rownames = F, 
         annotation_colors = annot_colors,
         annotation_row = row_annots,
         annotation_names_row = F,
         #drop_levels = TRUE, 
         fontsize = 10, 
         cluster_cols = T,
         cluster_rows = F,
         clustering_distance_cols=as.dist(1-cor(diffGenes.AVG, method="spearman")),
         cex=1,
         main = "")

# View modules of co-regulated genes ----
# view your color assignments for the different clusters
# look at these clusters in more detail later
module.assign <- data_subset_norm.clust.ordered$cluster
names(module.assign) <- rownames(data_subset_norm.clust.ordered)

#now assign a color to each module (makes it easy to identify and manipulate)
module.color <- brewer.pal(9, "PRGn")
module.color <- module.color[as.vector(module.assign)] 

names(module.color) <- names(module.assign) 
module.assign.df <- as_tibble(as.list(module.assign))
module.assign.pivot <- pivot_longer(module.assign.df, # dataframe to be pivoted
                          cols = everything(), # column names to be stored as a SINGLE variable
                          names_to = "geneID", # name of that new variable (column)
                          values_to = "module") # name of new variable (column) storing all the values (data)

module.assign.pivot <- module.assign.pivot %>%
  mutate(moduleColor = case_when(
    module == 1 ~ "#762A83",
    module == 2 ~ "#9970AB",
    module == 3 ~ "#C2A5CF",
    module == 4 ~ "#E7D4E8",
    module == 5 ~ "burlywood",
    module == 6 ~ "#D9F0D3",
    module == 7 ~ "#A6DBA0",
    module == 8 ~ "#5AAE61",
    module == 9 ~ "#1B7837"))

modsize <-ggplot(module.assign.pivot) +
  aes(as.character(module)) +
  geom_bar(aes(fill=moduleColor)) +
  labs(title = "Number of genes in clusters",
       x ="cluster")+
  scale_fill_identity()+
  theme_cowplot()

```

```{r Step 4.2 - Plot}
#plot_grid(clustered_data, modsize, HM, ncol = 2, nrow = 2)
clustered_data
modsize

```

```{r Step 4.3 - Heatmaps of Modules, include=FALSE}
# Choose a cluster(s) of interest ----
modulePick <- 1 #use 'c()' to grab more than one cluster from the heatmap.  e.g., c(1,2)

#now we pull out the genes from this module using a fancy subsetting operation on a named vector
myModule <- diffGenes.AVG[names(module.assign[module.assign %in% modulePick]),] 

for (i in unique(module.assign)) {
  myModule <- diffGenes.AVG[names(module.assign[module.assign %in% i]),] 
  assign(paste0("myModule", i), myModule)
  heatmap <- pheatmap(mat = myModule, 
         color = myheatcolors,
         scale="row",
         fontsize_col = 12,
         angle_col = 45,
         border_color = "black", 
         show_colnames = TRUE, 
         show_rownames = TRUE, 
         cellwidth = 25,
         cellheight = 12,
         annotation_colors = annot_colors,
         annotation_row = row_annots,
         drop_levels = TRUE, 
         fontsize = 12, 
         cluster_cols = T,
         cluster_rows = T,
         clustering_distance_cols=as.dist(1-cor(diffGenes.AVG, method="spearman")),
         cex=1,
         annotation_legend = F,
         annotation_names_row = F,
         main = paste0("Expression of module ", i, " genes"))
  assign(paste0("m", i), heatmap)
}

```

```{r PrintHeatmaps, fig.height= 4, fig.width=4}
m1
#plot_grid(m1,m2,m3,m4,m5,m6,m7,m8,m9, labels = "AUTO", nrow = 3, ncol = 3)
```

```{r Step 4.4 - GO ORA of Modules, fig.width = 10, fig.height=8}
# Load packages ----
library(tidyverse)
library(limma)
library(DT) 
library(GSEABase) 
library(Biobase) 
library(GSVA) 
library(gprofiler2) 
library(clusterProfiler) 
library(msigdbr) 
library(enrichplot) 

logScale <- function(input, input_start = 1, input_end = 50000, 
                     output_start = 2, output_end = 10) {
  m = (output_end - output_start)/(log(input_end) - log(input_start))
  b = -m * log(input_start) + output_start
  output = m * log(input) + b
  return(output)
}

# Carry out GO enrichment using gProfiler2 ----
# use topTable result to pick the top genes for carrying out a Gene Ontology (GO) enrichment analysis
myTopHitsUp <- resL_sig2[resL_sig2$logFC > 0,]
myTopHitsDown <- resL_sig2[resL_sig2$logFC < 0,]

# use the 'gost' function from the gprofiler2 package to run GO enrichment analysis

datalist = list()

for (i in 1:9) {
  df <- get(paste0("myModule", i))
  gost.res <- gost(rownames(df), 
                   organism = "hsapiens", 
                   correction_method = "fdr",
                   sources = c("GO", "KEGG", "REAC"),
                   custom_bg =rownames(resL_tb))
  if (is.null(gost.res)) {
    next
  } 
  
  gostTable <- data.frame(apply(gost.res[["result"]],2,as.character))
  
  essential_names <- c("source_order", "term_size", "term_name", 
                       "term_id", "source", "significant", "p_value")
  gostTable <- gostTable %>% dplyr::select(essential_names)
  gostTable <- gostTable %>% mutate_at(c('source_order', 'term_size', 'p_value'), as.numeric)
  gostTable$term_size_scaled <- logScale(gostTable$term_size)
  gostTable$module <- as.character(i)
  gostTable <- gostTable[1:5,]
  datalist[[i]] <- gostTable
}

myGO.df = do.call(rbind, datalist)

myGO.df <- myGO.df %>%
  mutate(moduleColor = case_when(
    module == 1 ~ "#762A83",
    module == 2 ~ "#9970AB",
    module == 3 ~ "#C2A5CF",
    module == 4 ~ "#E7D4E8",
    module == 5 ~ "burlywood",
    module == 6 ~ "#D9F0D3",
    module == 7 ~ "#A6DBA0",
    module == 8 ~ "#5AAE61",
    module == 9 ~ "#1B7837"))

ggplot(myGO.df, aes(x = module, y = term_name)) +
  geom_point(aes(size = term_size_scaled,
                 fill = moduleColor, alpha = -log10(p_value)),
             shape = 21) +
  scale_fill_identity() +  
  scale_alpha(range = c(0.4, 1)) +
  theme_bw()
```

***
## Gene Set Enrichment Analysis

```{r Step 5.1 - GSEA KEGG, fig.width = 10, fig.height=8}
library(clusterProfiler)
library(enrichplot)
library(ggplot2)
library(pathview)
library(ggridges)

# SET THE DESIRED ORGANISM HERE
organism = "org.Hs.eg.db"
#BiocManager::install(organism, character.only = TRUE)
library(organism, character.only = TRUE)

df <- resL_tb
df <- merge(df, TxOG, by='gene', all.x = T) %>% distinct(., gene, .keep_all = T)
df$entrezid <- unlist(sapply(df$entrezid,"[[",1))

# we want the log2 fold change 
original_gene_list <- df$logFC
# name the vector - 
names(original_gene_list) <- df$entrezid

# omit any NA values 
gene_list<-na.omit(original_gene_list)
removeNAnames <- names(gene_list) == "NA"
gene_list <- gene_list[!removeNAnames]

# sort the list in decreasing order (required for clusterProfiler)
gene_list = sort(gene_list, decreasing = TRUE)
kegg_organism = "hsa"

#After here, you can choose and run the analysis & visualizations according to your needs
#1 KEGG GSEA:####

kk2 <- gseKEGG(geneList     = gene_list,
               organism     = kegg_organism,
               minGSSize    = 10,
               maxGSSize    = 500,
               pvalueCutoff = 0.05,
               pAdjustMethod = "BH",
               keyType       = "ncbi-geneid"
)

pl.tab_kk = kk2@result

datatable(pl.tab_kk,
          extensions = c('KeyTable', "FixedHeader"),
          caption = 'Table 2: GSEA Resultss',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(4:8), digits=2)

write.table(pl.tab_kk, file = "../analysis/GSEA/KEGG/KEGG_CUSTOM_allLimma.txt", sep = "\t", quote = F, 
            row.names = F, col.names = T)

#1a. Visualizations : dotplot & ridgeplot

dplot <- dotplot(kk2, title = "KEGG GSEA NSCLC vs. Noncancer", font.size=12,
        showCategory = 10, split=".sign",) + facet_grid(.~.sign)

rplot <- ridgeplot(kk2) + labs(x = "enrichment distribution")

enr <- pairwise_termsim(kk2)
emplot <- emapplot(enr)

#1d.heatplots
p1 <- heatplot(kk2, showCategory=100)
p2 <- heatplot(kk2, foldChange=gene_list, showCategory=10)

dplot

```

```{r Step 5.2 - GSEA GO, fig.width = 10, fig.height=8}
#2. Gene Ontology GSEA####
library(clusterProfiler)
library(enrichplot)
library(ggplot2)
library(pathview)
library(ggridges)

# SET THE DESIRED ORGANISM HERE
organism = "org.Hs.eg.db"
#BiocManager::install(organism, character.only = TRUE)
library(organism, character.only = TRUE)

df <- resL_tb
# we want the log2 fold change 
original_gene_list <- df$logFC
names(original_gene_list) <- df$gene

# omit any NA values 
gene_list<-na.omit(original_gene_list)
# sort the list in decreasing order (required for clusterProfiler)
gene_list = sort(gene_list, decreasing = TRUE)

#analysis - change keytype accordingly, minGSsize is minimum number of genes forming a geneset
gse <- gseGO(geneList=gene_list, 
             ont ="MF", 
             keyType = "SYMBOL", 
             minGSSize = 10, 
             maxGSSize = 500, 
             pvalueCutoff = 0.05, 
             verbose = TRUE, 
             OrgDb = organism, 
             pAdjustMethod = "BH")

pl.tab = gse@result

datatable(pl.tab,
          extensions = c('KeyTable', "FixedHeader"),
          caption = 'Table 2: GSEA Resultss',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(4:8), digits=2)

write.table(pl.tab, file = "../analysis/GSEA/GO/GOBP_CUSTOM_MF.txt", sep = "\t", quote = F, 
            row.names = F, col.names = T)


#1a. Visualizations : dotplot & ridgeplot

dp2 <- dotplot(gse, showCategory = 10, title = "GO MF Overrepresentation", font.size=12,
        split=".sign") +
  facet_grid(.~.sign)

rp2 <- ridgeplot(gse) + labs(x = "enrichment distribution")

dp2
```

***
## Session Info

```{r Sessioninfo}
sessionInfo()
```

